/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for CM4 in the the Dual CPU Empty 
*              Application for ModusToolbox.
*
* Related Document: See README.md
*
*
*******************************************************************************
* (c) (2020), Cypress Semiconductor Corporation. All rights reserved.
*******************************************************************************
* This software, including source code, documentation and related materials
* ("Software"), is owned by Cypress Semiconductor Corporation or one of its
* subsidiaries ("Cypress") and is protected by and subject to worldwide patent
* protection (United States and foreign), United States copyright laws and
* international treaty provisions. Therefore, you may use this Software only
* as provided in the license agreement accompanying the software package from
* which you obtained this Software ("EULA").
*
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software source
* code solely for use in connection with Cypress's integrated circuit products.
* Any reproduction, modification, translation, compilation, or representation
* of this Software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer of such
* system or application assumes all risk of such use and in doing so agrees to
* indemnify Cypress against all liability.
*******************************************************************************/

#include "cy_pdl.h"
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"
#include "jpeg/jpg.h"

#define mSPI_MOSI               (P6_0)
#define mSPI_MISO               (P6_1)
#define mSPI_SCLK               (P6_2)
#define mSPI_SS                 (P6_3)

#define SPI_MTU 512u
#define SPI_SLAVE_READY_PIN P5_7

#define SPI_FREQ_HZ                (8000000UL)
#define CMD_TO_CMD_DELAY_MS        (1000UL)

#define SPI_MTU 512u
#define SPI_SLAVE_READY_PIN P5_7


#define IMG_WIDTH 128
#define IMG_HEIGHT 128


#define SCRN_WIDTH 	352
#define SCRN_HEIGHT 480
#define SCRN_SIZE 	(SCRN_WIDTH * SCRN_HEIGHT)

uint8 port9_fb[SCRN_SIZE] CY_SECTION(".cy_sharedmem");
uint8 port8_fb[SCRN_SIZE] CY_SECTION(".cy_sharedmem");

void handle_error(void)
{
     /* Disable all interrupts. */
    __disable_irq();

    CY_ASSERT(0);
}

uint32_t micros() {
	return Cy_TCPWM_Counter_GetCounter(UST_HW, UST_NUM);
}


void spi_data_ready() {
	spi_ready = 1;
}


int main(void)
{
uint8_t* huffman_data; //= malloc(8192);
uint8_t* ychannel; //= malloc(IMG_WIDTH * IMG_HEIGHT);
int huffman_data_i = 0;
uint8_t transmit_data[512];//= "BYE FROM PSOC";
uint8_t receive_data[512];
uint32_t frame_n = 0;
const char* sig = "FRSTART";
cyhal_spi_t mSPI;
uint8_t spi_ready = 0;


    cy_rslt_t result;

    result = cy_retarget_io_init( CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX,
                                  CY_RETARGET_IO_BAUDRATE);

    cyhal_gpio_init(CYBSP_USER_LED, CYHAL_GPIO_DIR_OUTPUT, CYHAL_GPIO_DRIVE_STRONG, 0);

    /* Enable global interrupts */

    Cy_TCPWM_Counter_Init(UST_HW, UST_NUM, &UST_config);
    Cy_TCPWM_Counter_Enable(UST_HW, UST_NUM);
    Cy_TCPWM_TriggerStart(UST_HW, UST_MASK);

    /* Initialize the User LED */

	printf("Configuring SPI master...\r\n");
	memset(&mSPI, 0, sizeof(mSPI));
	result = cyhal_spi_init( &mSPI, mSPI_MOSI, mSPI_MISO, mSPI_SCLK, mSPI_SS, NULL, 8, CYHAL_SPI_MODE_01_MSB, false);
	if (result != CY_RSLT_SUCCESS)
	{
		if (result == CYHAL_SPI_RSLT_PIN_CONFIG_NOT_SUPPORTED)
			printf("IUnsuprooted pins\n");
		else if (result == CYHAL_HWMGR_RSLT_ERR_INUSE)
			printf("CYHAL hardware in use...\n");
		else
			printf("UOther error\n");
		printf("Failed init SPI!\n");
		handle_error();
	}

	cyhal_spi_set_frequency( &mSPI, SPI_FREQ_HZ/2);

	/* Enable interrupts */
	cyhal_gpio_init(SPI_SLAVE_READY_PIN, CYHAL_GPIO_DIR_INPUT, CYHAL_GPIO_DRIVE_NONE, false);
	cyhal_gpio_enable_event(SPI_SLAVE_READY_PIN, CYHAL_GPIO_IRQ_RISE, 0, true);
	cyhal_gpio_register_callback(SPI_SLAVE_READY_PIN, spi_data_ready, NULL);

	huffman_data = malloc(8192);
	ychannel = malloc(IMG_WIDTH * IMG_HEIGHT);

    __enable_irq();

	while (1) {
		if (spi_ready) {
			printf("SPI READY!\n");
			cyhal_spi_transfer(&mSPI, transmit_data, SPI_MTU, receive_data, SPI_MTU, 0x31);

			if (strcmp(receive_data, sig) == 0) {
				frame_n++;
				memcpy(huffman_data, receive_data + 2 + 8, SPI_MTU - 8 - 2);
				huffman_data_i = SPI_MTU - 8 - 2;
			}
			else {
				memcpy(huffman_data + huffman_data_i, receive_data, SPI_MTU);
				if (receive_data[SPI_MTU - 3] == 0 && receive_data[SPI_MTU - 2] == 0 && receive_data[SPI_MTU - 1] == 0) {
					// frame is done. Process it.
					//for (int i = 0; i < huffman_data_i + )
					decompress_channel(ychannel, huffman_data, IMG_WIDTH, IMG_HEIGHT);
	#if 0
					for (int r = 0; r < IMG_HEIGHT; r++) {
						for (int c = 0; c < IMG_WIDTH; c++) {
							uint8_t val = ychannel[r * IMG_WIDTH + c];
							if (val > 16) putchar('.');
							else putchar(' ');
						}
						putchar('\n');
						putchar('\r');
					}
	#endif
					//break;
					int i = 0;
					for (int r = 20; r < 20 + 128; r++) {
						for (int c = 20; c < 20 + 128; c++) {
							port9_fb[r * SCRN_WIDTH + c] = ychannel[i] > 16? 0xff : 0x00;
							port8_fb[r * SCRN_WIDTH + c] = ychannel[i] > 16? 0xff : 0x00;
							i++;
						}
					}
				}
				else
					huffman_data_i += SPI_MTU;
			}
		}
	}
	while (1);

    int value = 0;
    int i = 0;
    for (;;)
    {
    	for (int r = 20; r < 120; r++) {
    		for (int c = 20; c < 120; c++) {
    			port9_fb[r * SCRN_WIDTH + c] = value == 0? c % 2? 0x00 : 0xff : 0xff;
    			port8_fb[r * SCRN_WIDTH + c] = value == 0? c % 2? 0x00 : 0xff : 0xff;
    		}
    	}
    	if (value == 0) value = 1;
    	else value = 0;
    	CyDelayUs(32000 + 289);	// 88 -> squailgle up, 89 -> squiggle down
    	/*if (port8_fb[0] == 0x00)
			cyhal_gpio_write(CYBSP_USER_LED, 1);
    	else
			cyhal_gpio_write(CYBSP_USER_LED, 0);*/
    }
}

/* [] END OF FILE */
