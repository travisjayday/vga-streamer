/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for CM4 in the the Dual CPU Empty 
*              Application for ModusToolbox.
*
* Related Document: See README.md
*
*
*******************************************************************************
* (c) (2020), Cypress Semiconductor Corporation. All rights reserved.
*******************************************************************************
* This software, including source code, documentation and related materials
* ("Software"), is owned by Cypress Semiconductor Corporation or one of its
* subsidiaries ("Cypress") and is protected by and subject to worldwide patent
* protection (United States and foreign), United States copyright laws and
* international treaty provisions. Therefore, you may use this Software only
* as provided in the license agreement accompanying the software package from
* which you obtained this Software ("EULA").
*
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software source
* code solely for use in connection with Cypress's integrated circuit products.
* Any reproduction, modification, translation, compilation, or representation
* of this Software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer of such
* system or application assumes all risk of such use and in doing so agrees to
* indemnify Cypress against all liability.
*******************************************************************************/

#include "cy_pdl.h"
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"
#include "jpeg/jpg.h"

#define mSPI_MOSI               (P6_0)
#define mSPI_MISO               (P6_1)
#define mSPI_SCLK               (P6_2)
#define mSPI_SS                 (P6_3)

#define SPI_MTU 512u
#define SPI_SLAVE_READY_PIN P5_7

#define SPI_FREQ_HZ                (11000000UL)
#define CMD_TO_CMD_DELAY_MS        (1000UL)

#define SPI_MTU 512u
#define SPI_SLAVE_READY_PIN P5_7
#define SPI_SLAVE_READY_PIN_PORT P5_7_PORT

#define IMG_WIDTH 144
#define IMG_HEIGHT 144
#define SUBSAMPLE_CHROMA 4
#define CHROMA_WIDTH (IMG_WIDTH / SUBSAMPLE_CHROMA)
#define CHROMA_HEIGHT (IMG_HEIGHT / SUBSAMPLE_CHROMA)
#define NUM_COLORS 16
#define COLOR_SCALER (256/NUM_COLORS)

#define SCRN_WIDTH 	352
#define SCRN_HEIGHT 480
#define SCRN_SIZE 	(SCRN_WIDTH * SCRN_HEIGHT)

volatile uint8 port9_fb[SCRN_SIZE] CY_SECTION(".cy_sharedmem");
volatile uint8 port8_fb[SCRN_SIZE] CY_SECTION(".cy_sharedmem");

void handle_error(void)
{
     /* Disable all interrupts. */
    __disable_irq();

    CY_ASSERT(0);
}

uint32_t micros() {
	return Cy_TCPWM_Counter_GetCounter(UST_HW, UST_NUM);
}

volatile uint8_t spi_ready = 0;

void spi_data_ready() {
	spi_ready = 1;
	Cy_GPIO_ClearInterrupt(SPI_SLAVE_READY_PIN_PORT, SPI_SLAVE_READY_PIN);
}

struct pix {
    uint8_t r;
    uint8_t g;
    uint8_t b;
};

#define CLAMP_F(f) f > 255? 255 : f < 0? 0 : (uint8_t) f

//#define USE_FLOAT_COLORMAT


void
dec_ycrcb_blk(uint8_t* y_blk, uint8_t* cr_blk, uint8_t* cb_blk,
        uint8_t subsampl_cr, uint32_t row_base, uint32_t col_base, uint32_t width, uint32_t height)
{
    int32_t y;
    int32_t cr;
    int32_t cb;

    int i = 0;
    for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) {
            y  = y_blk[r * width + c];
            cr = cr_blk[(r/subsampl_cr * width/subsampl_cr) + c / subsampl_cr] - (256 / 2) / COLOR_SCALER;
            cb = cb_blk[(r/subsampl_cr * width/subsampl_cr) + c / subsampl_cr] - (256 / 2) / COLOR_SCALER;

#ifdef USE_FLOAT_COLORMAT
            float redf = 1 * y +   0      * cb +  1.5748 * cr;
            float grnf = 1 * y +  -0.1873 * cb + -0.4681 * cr;
            float bluf = 1 * y +   1.8556 * cb +  0      * cr;

#else
            int16_t red = ((1<<21) * y + 0       * cb + 3302595 * cr) >> 21;
            int16_t grn = ((1<<21) * y - 392796  * cb - 981677  * cr) >> 21;        // same, more, less
            int16_t blu = ((1<<21) * y + 3891475 * cb + 0       * cr) >> 21;
#endif
            uint8_t port8 = red | (grn << 5);
            uint8_t port9 = (grn >> 2) | (blu << 5);

            red = red > 15? 15 : red;
            red = red < 0? 0 : red;
            port8_fb[(row_base + r) * SCRN_WIDTH + (col_base + c)] = red<<3;
            port9_fb[(row_base + r) * SCRN_WIDTH + (col_base + c)] = red<<4;
        }
    }
}

void
dec_ycrcb(uint8_t* y_blk, uint8_t* cb_blk, uint8_t* cr_blk,
        uint8_t subsampl_cr, uint32_t row_base, uint32_t col_base, uint32_t width, uint32_t height)
{
    for (uint32_t r = 0; r < height; r += 8) {
        for (uint32_t c = 0; c < width; c += 8) {
            dec_ycrcb_blk(y_blk + r * width + c,
                         cr_blk + (r/subsampl_cr * width/subsampl_cr) + c/subsampl_cr,
                         cb_blk + (r/subsampl_cr * width/subsampl_cr) + c/subsampl_cr,
                         subsampl_cr,
						 row_base + r, col_base + c,
                         width, height);
        }
    }
}

int main(void)
{
	uint8_t* huffman_data; //= malloc(8192);
	uint8_t* ychannel; //= malloc(IMG_WIDTH * IMG_HEIGHT);
	uint8_t* cbchannel; //= malloc(IMG_WIDTH * IMG_HEIGHT);
	uint8_t* crchannel; //= malloc(IMG_WIDTH * IMG_HEIGHT);
	int huffman_data_i = 0;
	uint8_t transmit_data[512];//= "BYE FROM PSOC";
	uint8_t receive_data[512];
	uint32_t frame_n = 0;
	const char* sig = "FRSTART";
	cyhal_spi_t mSPI;


    cy_rslt_t result;

    result = cy_retarget_io_init( CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX,
                                  CY_RETARGET_IO_BAUDRATE);

    printf("Active PC: %d\n", Cy_Prot_GetActivePC(CPUSS_MS_ID_CM4));
    //Cy_Prot_ConfigBusMaster(busMaster, privileged, secure, pcMask)

    printf("CY_PROT_BASE: %p\n", CY_PROT_BASE);
    volatile uint32_t* MS0_CTL = 0x40230000;
    volatile uint32_t* MS1_CTL = 0x40230004;
    volatile uint32_t* MS2_CTL = 0x40230008;
    volatile uint32_t* MS3_CTL = 0x4023000C;
    volatile uint32_t* MS14_CTL= 0x40230038;
    volatile uint32_t* MS15_CTL= 0x4023003C;

    *MS14_CTL = 0b1100000011;		// CM4
    *MS15_CTL = 0b1100000011;		// TC
    *MS0_CTL = 0b0000000011;		// CM0+
    *MS2_CTL = 0b0000000011;		// DW0
    *MS3_CTL = 0b0000000011;		// DW1

    printf("MS0_CTL: %x\n", *MS0_CTL);
    printf("MS2_CTL: %x\n", *MS2_CTL);
    printf("MS3_CTL: %x\n", *MS3_CTL);
    printf("MS14_CTL: %x\n",*MS14_CTL);


    cyhal_gpio_init(CYBSP_USER_LED, CYHAL_GPIO_DIR_OUTPUT, CYHAL_GPIO_DRIVE_STRONG, 0);

    /* Enable global interrupts */

    Cy_TCPWM_Counter_Init(UST_HW, UST_NUM, &UST_config);
    Cy_TCPWM_Counter_Enable(UST_HW, UST_NUM);
    Cy_TCPWM_TriggerStart(UST_HW, UST_MASK);

    /* Initialize the User LED */

	printf("Configuring SPI master...\r\n");
	memset(&mSPI, 0, sizeof(mSPI));
	result = cyhal_spi_init( &mSPI, mSPI_MOSI, mSPI_MISO, mSPI_SCLK, mSPI_SS, NULL, 8, CYHAL_SPI_MODE_01_MSB, false);
	if (result != CY_RSLT_SUCCESS)
	{
		if (result == CYHAL_SPI_RSLT_PIN_CONFIG_NOT_SUPPORTED)
			printf("IUnsuprooted pins\n");
		else if (result == CYHAL_HWMGR_RSLT_ERR_INUSE)
			printf("CYHAL hardware in use...\n");
		else
			printf("UOther error\n");
		printf("Failed init SPI!\n");
		handle_error();
	}

	cyhal_spi_set_frequency( &mSPI, SPI_FREQ_HZ/2);

	/* Enable interrupts */
	cyhal_gpio_init(SPI_SLAVE_READY_PIN, CYHAL_GPIO_DIR_INPUT, CYHAL_GPIO_DRIVE_NONE, false);
	cyhal_gpio_enable_event(SPI_SLAVE_READY_PIN, CYHAL_GPIO_IRQ_RISE, 0, true);
	cyhal_gpio_register_callback(SPI_SLAVE_READY_PIN, spi_data_ready, NULL);

	huffman_data = malloc(8192);

	ychannel = malloc(IMG_WIDTH * IMG_HEIGHT);
	cbchannel = malloc(CHROMA_WIDTH * CHROMA_HEIGHT);
	crchannel = malloc(CHROMA_WIDTH * CHROMA_HEIGHT);

    __enable_irq();

    port9_fb[0] = 0x00;
    uint32_t start_t = micros();
    uint8_t k = 0;

    spi_ready = 1;
	while (1) {
		/* If ESP had data available and we just VSynced */
		if (spi_ready /*&& port9_fb[0] == 0xff*/) {
			spi_ready = 0;

			/* Do SPI transaction */
			cyhal_spi_transfer(&mSPI, transmit_data, SPI_MTU, receive_data, SPI_MTU, 0x31);

			if (strcmp(receive_data, sig) == 0) {
				frame_n++;
				memcpy(huffman_data, receive_data + 2 + 8, SPI_MTU - 8 - 2);
				huffman_data_i = SPI_MTU - 8 - 2;
			}
			else {
				memcpy(huffman_data + huffman_data_i, receive_data, SPI_MTU);
				if (receive_data[SPI_MTU - 3] == 0 && receive_data[SPI_MTU - 2] == 0 && receive_data[SPI_MTU - 1] == 0) {
					// frame is done. Process it.
					/* Decode Y takes O(2ms) for 128x128 image */
					int sum = 0;
					for (int i = 0; i < huffman_data_i + SPI_MTU; i++)
						sum += huffman_data[i];

					start_t = micros();
					huffman_data_i = decompress_channel(ychannel, huffman_data, IMG_WIDTH, IMG_HEIGHT);
					huffman_data_i += decompress_channel(cbchannel, huffman_data+huffman_data_i, CHROMA_WIDTH, CHROMA_HEIGHT);
					decompress_channel(crchannel, huffman_data+huffman_data_i, CHROMA_WIDTH, CHROMA_HEIGHT);
					dec_ycrcb(ychannel, cbchannel, crchannel, SUBSAMPLE_CHROMA, 80, 80, IMG_WIDTH, IMG_HEIGHT);
					uint32_t end_t = micros();
					printf("Decompression time: %dms\n", (end_t-start_t)/1000);
					/*int i = 0;
					for (int r = 80; r < 80 + IMG_HEIGHT; r++) {
						for (int c = 20; c < 20 + IMG_WIDTH; c++) {
							port9_fb[r * SCRN_WIDTH + c] = ychannel[i] > 16? 0xff : 0x00;
							//port8_fb[r * SCRN_WIDTH + c] = ychannel[i] > 16? 0xff : 0x00;
							i++;
						}
					}*/
				}
				else
					huffman_data_i += SPI_MTU;
			}
		}
	}
	while (1);

    int value = 0;
    int i = 0;
    for (;;)
    {
    	for (int r = 20; r < 120; r++) {
    		for (int c = 20; c < 120; c++) {
    			port9_fb[r * SCRN_WIDTH + c] = value == 0? c % 2? 0x00 : 0xff : 0xff;
    			port8_fb[r * SCRN_WIDTH + c] = value == 0? c % 2? 0x00 : 0xff : 0xff;
    		}
    	}
    	if (value == 0) value = 1;
    	else value = 0;
    	CyDelayUs(32000 + 289);	// 88 -> squailgle up, 89 -> squiggle down
    	/*if (port8_fb[0] == 0x00)
			cyhal_gpio_write(CYBSP_USER_LED, 1);
    	else
			cyhal_gpio_write(CYBSP_USER_LED, 0);*/
    }
}

/* [] END OF FILE */
